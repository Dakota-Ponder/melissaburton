// js library that attaches event listeners to breakpoints

var breakpoints = (function () {
  "use strict"; // use strict mode for safer JS code
  // q: what does use strict do?

  // main function that initializes the module with the given breakpoints
  function e(e) {
    t.init(e);
  }

  // main object containing methods & properties for the breakpoint handling
  var t = {
    list: null, // list of breakpoints
    media: {}, // store media queries
    events: [], // list of events that get triggered on breakpoint change

    // initialization function that binds necessary events
    init: function (e) {
      (t.list = e),
        window.addEventListener("resize", t.poll),
        window.addEventListener("orientationchange", t.poll),
        window.addEventListener("load", t.poll),
        window.addEventListener("fullscreenchange", t.poll);
    },

    // function that checks if the given breakpoint is active
    active: function (e) {
      // n: name, a: action, s: state, i: item, r: range, d: dimension, c: unit
      var n, a, s, i, r, d, c;
      if (!(e in t.media)) {
        if (
          (">=" == e.substr(0, 2)
            ? ((a = "gte"), (n = e.substr(2)))
            : "<=" == e.substr(0, 2)
            ? ((a = "lte"), (n = e.substr(2)))
            : ">" == e.substr(0, 1)
            ? ((a = "gt"), (n = e.substr(1)))
            : "<" == e.substr(0, 1)
            ? ((a = "lt"), (n = e.substr(1)))
            : "!" == e.substr(0, 1)
            ? ((a = "not"), (n = e.substr(1)))
            : ((a = "eq"), (n = e)),
          n && n in t.list)
        )
          if (((i = t.list[n]), Array.isArray(i))) {
            if (((r = parseInt(i[0])), (d = parseInt(i[1])), isNaN(r))) {
              if (isNaN(d)) return;
              c = i[1].substr(String(d).length);
            } else c = i[0].substr(String(r).length);
            if (isNaN(r))
              switch (a) {
                case "gte":
                  s = "screen";
                  break;
                case "lte":
                  s = "screen and (max-width: " + d + c + ")";
                  break;
                case "gt":
                  s = "screen and (min-width: " + (d + 1) + c + ")";
                  break;
                case "lt":
                  s = "screen and (max-width: -1px)";
                  break;
                case "not":
                  s = "screen and (min-width: " + (d + 1) + c + ")";
                  break;
                default:
                  s = "screen and (max-width: " + d + c + ")";
              }
            else if (isNaN(d))
              switch (a) {
                case "gte":
                  s = "screen and (min-width: " + r + c + ")";
                  break;
                case "lte":
                  s = "screen";
                  break;
                case "gt":
                  s = "screen and (max-width: -1px)";
                  break;
                case "lt":
                  s = "screen and (max-width: " + (r - 1) + c + ")";
                  break;
                case "not":
                  s = "screen and (max-width: " + (r - 1) + c + ")";
                  break;
                default:
                  s = "screen and (min-width: " + r + c + ")";
              }
            else
              switch (a) {
                case "gte":
                  s = "screen and (min-width: " + r + c + ")";
                  break;
                case "lte":
                  s = "screen and (max-width: " + d + c + ")";
                  break;
                case "gt":
                  s = "screen and (min-width: " + (d + 1) + c + ")";
                  break;
                case "lt":
                  s = "screen and (max-width: " + (r - 1) + c + ")";
                  break;
                case "not":
                  s =
                    "screen and (max-width: " +
                    (r - 1) +
                    c +
                    "), screen and (min-width: " +
                    (d + 1) +
                    c +
                    ")";
                  break;
                default:
                  s =
                    "screen and (min-width: " +
                    r +
                    c +
                    ") and (max-width: " +
                    d +
                    c +
                    ")";
              }
          } else s = "(" == i.charAt(0) ? "screen and " + i : i;
        t.media[e] = !!s && s;
      }
      return t.media[e] !== !1 && window.matchMedia(t.media[e]).matches;
    },

    // add an event listener for a given breakpoint
    on: function (e, n) {
      t.events.push({ query: e, handler: n, state: !1 }), t.active(e) && n();
    },

    // poll function that checks if a breakpoint has been reached
    // and triggers the corresponding event
    poll: function () {
      var e, n; // e: event, n: event handler

      // loop through all events and triggers handlers if necessary
      for (e = 0; e < t.events.length; e++)
        (n = t.events[e]),
          t.active(n.query)
            ? n.state || ((n.state = !0), n.handler())
            : n.state && (n.state = !1);
    },
  };

  // return the public methods and properties of the module

  return (
    (e._ = t),
    (e.on = function (e, n) {
      t.on(e, n);
    }),
    (e.active = function (e) {
      return t.active(e);
    }),
    e
  );
})();

// universal module definition pattern,
// allowing the breakpoints function to be used as a module or a globally
!(function (e, t) {
  "function" == typeof define && define.amd
    ? define([], t) // AMD (Asynchronous Module Definition) format
    : "object" == typeof exports
    ? (module.exports = t()) // CommonJS/Node.js format
    : (e.breakpoints = t()); // global object
})(this, function () {
  return breakpoints;
});
